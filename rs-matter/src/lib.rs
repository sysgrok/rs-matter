/*
 *
 *    Copyright (c) 2020-2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

//! Native Rust Implementation of Matter (Smart-Home)
//!
//! This crate implements the Matter specification that can be run on embedded devices
//! to build Matter-compatible smart-home/IoT devices.
//!
//! Currently Ethernet based transport is supported.
//!
//! # Examples
//! ```ignore
//! /// TODO: Fix once new API has stabilized a bit
//! use rs_matter::{Matter, CommissioningData};
//! use rs_matter::dm::device_types::device_type_add_on_off_light;
//! use rs_matter::dm::cluster_basic_information::BasicInfoConfig;
//! use rs_matter::sc::spake2p::VerifierData;
//!
//! # use rs_matter::dm::sdm::dev_att::{DataType, DevAttDataFetcher};
//! # use rs_matter::error::Error;
//! # pub struct DevAtt{}
//! # impl DevAttDataFetcher for DevAtt{
//! # fn get_devatt_data(&self, data_type: DataType, data: &mut [u8]) -> Result<usize, Error> { Ok(0) }
//! # }
//! # let dev_att = Box::new(DevAtt{});
//!
//! /// The commissioning data for this device
//! let comm_data = CommissioningData {
//!     verifier: VerifierData::new_with_pw(123456),
//!     discriminator: 250,
//! };
//!
//! /// The basic information about this device
//! let dev_info = BasicInfoConfig {
//!     vid: 0x8000,
//!     pid: 0xFFF1,
//!     hw_ver: 2,
//!     sw_ver: 1,
//!     sw_ver_str: "1".to_string(),
//!     serial_no: "aabbcc".to_string(),
//!     device_name: "OnOff Light".to_string(),
//! };
//!
//! /// Get the Matter Object
//! /// The dev_att is an object that implements the DevAttDataFetcher trait.
//! let mut matter = Matter::new(dev_info, dev_att, comm_data).unwrap();
//! let dm = matter.get_data_model();
//! {
//!     let mut node = dm.node.write().unwrap();
//!     /// Add our device-types
//!     let endpoint = device_type_add_on_off_light(&mut node).unwrap();
//! }
//! // Start the Matter Daemon
//! // matter.start_daemon().unwrap();
//! ```
//!
//! Start off exploring by going to the [Matter] object.
#![cfg_attr(not(feature = "std"), no_std)]
#![allow(async_fn_in_trait)]
#![allow(unknown_lints)]
#![allow(clippy::uninlined_format_args)]
#![recursion_limit = "1024"]

use embassy_sync::blocking_mutex::raw::NoopRawMutex;

use crate::dm::clusters::basic_info::{BasicInfoConfig, BasicInfoSettings};
use crate::dm::clusters::dev_att::DevAttDataFetcher;
use crate::error::{Error, ErrorCode};
use crate::fabric::FabricMgr;
use crate::failsafe::FailSafe;
use crate::pairing::{print_pairing_code_and_qr, DiscoveryCapabilities};
use crate::sc::pake::PaseMgr;
use crate::transport::network::{NetworkReceive, NetworkSend};
use crate::transport::session::SessionMgr;
use crate::transport::{PacketBufferExternalAccess, TransportMgr};
use crate::utils::cell::RefCell;
use crate::utils::epoch::Epoch;
use crate::utils::init::{init, Init};
use crate::utils::rand::Rand;
use crate::utils::storage::pooled::BufferAccess;
use crate::utils::storage::WriteBuf;
use crate::utils::sync::blocking::Mutex;
use crate::utils::sync::Notification;

/// Re-export the `rs_matter_macros::import` proc-macro
pub use rs_matter_macros::import;

#[cfg(feature = "alloc")]
extern crate alloc;

// This mod MUST go first, so that the others see its macros.
pub(crate) mod fmt;

pub mod acl;
pub mod cert;
pub mod crypto;
pub mod dm;
pub mod error;
pub mod fabric;
pub mod failsafe;
pub mod group_keys;
pub mod im;
pub mod pairing;
pub mod persist;
pub mod respond;
pub mod sc;
pub mod tlv;
pub mod transport;
pub mod utils;

/// Re-export several crates
///
/// This is necessary for crates used in the code generated by the proc-macros
pub mod reexport {
    pub use bitflags;
    #[cfg(feature = "defmt")]
    pub use defmt;
    #[cfg(feature = "log")]
    pub use log;
    pub use strum;
}

#[cfg(feature = "alloc")]
#[macro_export]
macro_rules! alloc {
    ($val:expr) => {
        alloc::boxed::Box::new($val)
    };
}

#[cfg(not(feature = "alloc"))]
#[macro_export]
macro_rules! alloc {
    ($val:expr) => {
        $val
    };
}

/// The Matter UDP port
pub const MATTER_PORT: u16 = 5540;

/// The maximum length of a Matter mDNS service name
pub const MATTER_SERVICE_MAX_NAME_LEN: usize = 33;

/// A type capturing all the information necessary to publish a commissioned
/// Matter fabric or a non-commissioned Matter instance over mDNS.
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum MatterMdnsService {
    /// A commissioned Matter service for a particular fabric
    ///
    /// The published name is in the form `<compressed-fabric-id-hex>-<node-id-hex>`.
    Commissioned {
        compressed_fabric_id: u64,
        node_id: u64,
    },
    /// A non-commissioned Matter service
    ///
    /// The published name is in the form `<id-hex>`. The discriminator should be used as an mDNS TXT entry
    Commissionable {
        id: u64,
        /// The discriminator to be communicated over mDNS
        discriminator: u16,
    },
}

impl MatterMdnsService {
    /// Return the name of the mDNS service in a buffer
    ///
    /// NOTE: The buffer needs to be at least `MATTER_SERVICE_MAX_NAME_LEN` bytes long
    /// or else this method will panic.
    pub fn name<'a>(&self, buf: &'a mut [u8]) -> &'a str {
        use core::fmt::Write;

        match self {
            Self::Commissioned {
                compressed_fabric_id,
                node_id,
            } => {
                if buf.len() < MATTER_SERVICE_MAX_NAME_LEN {
                    panic!("Buffer too small for mDNS service name");
                }

                let mut wb = WriteBuf::new(buf);

                write_unwrap!(&mut wb, "{:016X}", compressed_fabric_id);

                unwrap!(wb.append(b"-"));

                write_unwrap!(&mut wb, "{:016X}", node_id);

                let len = wb.get_tail();

                unwrap!(
                    core::str::from_utf8(&buf[..len]),
                    "Invalid UTF-8 in mDNS service name"
                )
            }
            Self::Commissionable { id, .. } => {
                if buf.len() < 16 {
                    panic!("Buffer too small for mDNS service name");
                }

                let mut wb = WriteBuf::new(buf);

                write_unwrap!(&mut wb, "{:016X}", id);

                let len = wb.get_tail();

                unwrap!(
                    core::str::from_utf8(&buf[..len]),
                    "Invalid UTF-8 in mDNS service name"
                )
            }
        }
    }
}

/// Device basic commissioning data
#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct BasicCommData {
    /// The password which is necessary to authenticate the device in either
    /// initial commissioning, or when the basic commissioning window is opened
    pub password: u32,
    /// The 12-bit discriminator used to differentiate between multiple devices
    pub discriminator: u16,
}

pub struct MatterState {
    pub fabrics: FabricMgr,
    pub pase: PaseMgr,
    pub failsafe: FailSafe,
    pub basic_info_settings: BasicInfoSettings,
    pub sessions: SessionMgr,
}

impl MatterState {
    const fn new(epoch: Epoch, rand: Rand) -> Self {
        Self {
            fabrics: FabricMgr::new(),
            pase: PaseMgr::new(epoch, rand),
            failsafe: FailSafe::new(epoch, rand),
            basic_info_settings: BasicInfoSettings::new(),
            sessions: SessionMgr::new(epoch, rand),
        }        
    }

    fn init(epoch: Epoch, rand: Rand) -> impl Init<Self> {
        init!(Self {
            fabrics <- FabricMgr::init(),
            pase <- PaseMgr::init(epoch, rand),
            failsafe <- FailSafe::init(epoch, rand),
            basic_info_settings <- BasicInfoSettings::init(),
            sessions <- SessionMgr::init(epoch, rand),
        })
    }
}

pub trait Matter {
    fn initialize_transport_buffers(&self) -> Result<(), Error>;

    fn dev_det(&self) -> &BasicInfoConfig<'_>;

    fn dev_att(&self) -> &dyn DevAttDataFetcher;

    fn dev_comm(&self) -> &BasicCommData;

    fn port(&self) -> u16;

    fn rand(&self) -> Rand;

    fn epoch(&self) -> Epoch;

    fn transport_rx_buffer(&self) -> impl BufferAccess<[u8]> + '_;

    fn transport_tx_buffer(&self) -> impl BufferAccess<[u8]> + '_;

    fn state<F: FnOnce(&mut MatterState) -> R, R>(&self, f: F) -> R;

    fn transport(&self) -> &TransportMgr;

    /// Return `true` if there is at least one commissioned fabric
    //
    // TODO:
    // The implementation of this method needs to change in future,
    // because the current implementation does not really track whether
    // `CommissioningComplete` had been actually received for the fabric.
    //
    // The fabric is created once we receive `AddNoc`, but that's just
    // not enough. The fabric should NOT be considered commissioned until
    // after we receive `CommissioningComplete` on behalf of a Case session
    // for the fabric in question.
    fn is_commissioned(&self) -> bool;

    /// Enable basic commissioning by setting up a PASE session and printing the pairing code and QR code.
    ///
    /// The method will return an error if there is not enough space in the buffer to print the pairing code and QR code
    /// or if the PASE session could not be set up (due to another PASE session already being active, for example).
    ///
    /// Parameters:
    /// * `discovery_capabilities`: The discovery capabilities of the device (IP, BLE or Soft-AP)
    /// * `timeout_secs`: The timeout in seconds for the basic commissioning session
    async fn enable_basic_commissioning(
        &self,
        discovery_capabilities: DiscoveryCapabilities,
        timeout_secs: u16,
    ) -> Result<(), Error>;

    /// Disable the basic commissioning session
    ///
    /// The method will return Ok(false) if there is no active PASE session to disable.
    fn disable_commissioning(&self) -> Result<bool, Error>;

    /// Run the transport layer
    ///
    /// Enables basic commissioning if the device is not commissioned
    /// Note that the fabrics should be loaded by the PSM before calling this method
    /// or else commissioning will be always enabled.
    async fn run<S, R>(
        &self,
        send: S,
        recv: R,
        discovery_capabilities: DiscoveryCapabilities,
    ) -> Result<(), Error>
    where
        S: NetworkSend,
        R: NetworkReceive;

    /// Resets the transport layer by clearing all sessions, exchanges, the RX buffer and the TX buffer
    /// NOTE: User should be careful _not_ to call this method while the transport layer and/or the built-in mDNS is running.
    fn reset_transport(&self) -> Result<(), Error>;

    /// Run the transport layer
    async fn run_transport<S, R>(&self, send: S, recv: R) -> Result<(), Error>
    where
        S: NetworkSend,
        R: NetworkReceive;

    /// Notify that the ACLs, Fabrics or Basic Info _might_ have changed
    /// This method is supposed to be called after processing SC and IM messages that might affect the ACLs, Fabrics or Basic Info.
    ///
    /// The default IM and SC handlers (`DataModel` and `SecureChannel`) do call this method after processing the messages.
    ///
    /// TODO: Fix the method name as it is not clear enough. Potentially revamp the whole persistence notification logic
    fn notify_persist(&self);

    fn load_fabrics(&self, data: &[u8]) -> Result<(), Error>;

    fn store_fabrics<'b>(&self, buf: &'b mut [u8]) -> Result<Option<&'b [u8]>, Error>;

    fn fabrics_changed(&self) -> bool;

    fn load_basic_info(&self, data: &[u8]) -> Result<(), Error>;

    fn store_basic_info<'b>(&self, buf: &'b mut [u8]) -> Result<Option<&'b [u8]>, Error>;

    fn basic_info_changed(&self) -> bool;

    /// A hook for user persistence code to wait for potential changes in ACLs, Fabrics or basic info.
    ///
    /// Once this future resolves, user code is supposed to inspect ACLs, Fabrics and basic info for changes, and
    /// if there are changes, persist them.
    ///
    /// TODO: Fix the method name as it is not clear enough. Potentially revamp the whole persistence notification logic
    async fn wait_persist(&self);

    fn mdns_services<F>(&self, f: F) -> Result<(), Error>
    where 
        F: FnMut(MatterMdnsService) -> Result<(), Error>;

    /// Notify that the Matter mDNS services _might_ have changed.
    /*pub(crate)*/ fn notify_mdns(&self);

    /// A hook for user code to wait for notification that the Matter mDNS services might have changed.
    ///
    /// Once this future resolves, user code is supposed to inspect the mDNS services for changes, and
    /// if there are changes, re-publish the changed mDNS services in an mDNS responder accordingly.
    async fn wait_mdns(&self);
}

impl<T> Matter for &T 
where 
    T: Matter,
{
    fn initialize_transport_buffers(&self) -> Result<(), Error> {
        (**self).initialize_transport_buffers()
    }

    fn state<F: FnOnce(&mut MatterState) -> R, R>(&self, f: F) -> R {
        (**self).state(f)
    }

    fn transport(&self) -> &TransportMgr {
        (**self).transport()
    }

    fn dev_det(&self) -> &BasicInfoConfig<'_> {
        (**self).dev_det()
    }

    fn dev_att(&self) -> &dyn DevAttDataFetcher {
        (**self).dev_att()
    }

    fn dev_comm(&self) -> &BasicCommData {
        (**self).dev_comm()
    }

    fn port(&self) -> u16 {
        (**self).port()
    }

    fn rand(&self) -> Rand {
        (**self).rand()
    }

    fn epoch(&self) -> Epoch {
        (**self).epoch()
    }

    fn transport_rx_buffer(&self) -> impl BufferAccess<[u8]> + '_ {
        (**self).transport_rx_buffer()
    }

    fn transport_tx_buffer(&self) -> impl BufferAccess<[u8]> + '_ {
        (**self).transport_tx_buffer()
    }

    fn is_commissioned(&self) -> bool {
        (**self).is_commissioned()
    }

    async fn enable_basic_commissioning(
        &self,
        discovery_capabilities: DiscoveryCapabilities,
        timeout_secs: u16,
    ) -> Result<(), Error> {
        (**self).enable_basic_commissioning(discovery_capabilities, timeout_secs).await
    }

    fn disable_commissioning(&self) -> Result<bool, Error> {
        (**self).disable_commissioning()
    }

    async fn run<S, R>(
        &self,
        send: S,
        recv: R,
        discovery_capabilities: DiscoveryCapabilities,
    ) -> Result<(), Error>
    where
        S: NetworkSend,
        R: NetworkReceive,
    {
        (**self).run(send, recv, discovery_capabilities).await
    }

    fn reset_transport(&self) -> Result<(), Error> {
        (**self).reset_transport()
    }

    async fn run_transport<S, R>(&self, send: S, recv: R) -> Result<(), Error> 
    where
        S: NetworkSend,
        R: NetworkReceive,
    {
        (**self).run_transport(send, recv).await
    }

    fn notify_persist(&self) {
        (**self).notify_persist();
    }

    fn load_fabrics(&self, data: &[u8]) -> Result<(), Error> {
        (**self).load_fabrics(data)
    }

    fn store_fabrics<'b>(&self, buf: &'b mut [u8]) -> Result<Option<&'b [u8]>, Error> {
        (**self).store_fabrics(buf)
    }

    fn fabrics_changed(&self) -> bool {
        (**self).fabrics_changed()
    }

    fn load_basic_info(&self, data: &[u8]) -> Result<(), Error> {
        (**self).load_basic_info(data)
    }

    fn store_basic_info<'b>(&self, buf: &'b mut [u8]) -> Result<Option<&'b [u8]>, Error> {
        (**self).store_basic_info(buf)
    }

    fn basic_info_changed(&self) -> bool {
        (**self).basic_info_changed()
    }

    async fn wait_persist(&self) {
        (**self).wait_persist().await;
    }

    fn mdns_services<F>(&self, f: F) -> Result<(), Error>
    where 
        F: FnMut(MatterMdnsService) -> Result<(), Error>,
    {
        (**self).mdns_services(f)
    }

    fn notify_mdns(&self) {
        (**self).notify_mdns();
    }

    async fn wait_mdns(&self) {
        (**self).wait_mdns().await;
    }
}

/// The primary Matter Object
pub struct MatterInstance<'a> {
    state: Mutex<NoopRawMutex, RefCell<MatterState>>,
    transport_mgr: TransportMgr,
    persist_notification: Notification<NoopRawMutex>,
    mdns_notification: Notification<NoopRawMutex>,
    epoch: Epoch,
    rand: Rand,
    dev_det: &'a BasicInfoConfig<'a>,
    dev_comm: BasicCommData,
    dev_att: &'a dyn DevAttDataFetcher,
    port: u16,
}

impl<'a> MatterInstance<'a> {
    /// Create a new Matter object when support for the Rust Standard Library is enabled.
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    #[cfg(feature = "std")]
    #[inline(always)]
    pub const fn new_default(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DevAttDataFetcher,
        port: u16,
    ) -> Self {
        use crate::utils::epoch::sys_epoch;
        use crate::utils::rand::sys_rand;

        Self::new(dev_det, dev_comm, dev_att, sys_epoch, sys_rand, port)
    }

    /// Create a new Matter object
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * epoch: A function of type [Epoch]. This function is responsible for providing the current
    ///   "unix" time in milliseconds
    /// * rand: A function of type [Rand]. This function is responsible for generating random data.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    #[inline(always)]
    pub const fn new(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DevAttDataFetcher,
        epoch: Epoch,
        rand: Rand,
        port: u16,
    ) -> Self {
        Self {
            state: Mutex::new(RefCell::new(MatterState::new(epoch, rand))),
            transport_mgr: TransportMgr::new(dev_det, rand),
            persist_notification: Notification::new(),
            mdns_notification: Notification::new(),
            epoch,
            rand,
            dev_det,
            dev_comm,
            dev_att,
            port,
        }
    }

    /// Create an in-place initializer for a Matter object
    /// when support for the Rust Standard Library is enabled.
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    #[cfg(feature = "std")]
    pub fn init_default(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DevAttDataFetcher,
        port: u16,
    ) -> impl Init<Self> {
        use crate::utils::epoch::sys_epoch;
        use crate::utils::rand::sys_rand;

        Self::init(dev_det, dev_comm, dev_att, sys_epoch, sys_rand, port)
    }

    /// Create an in-place initializer for a Matter object
    ///
    /// # Parameters
    /// * dev_det: An object of type [BasicInfoConfig].
    /// * dev_comm: An object of type [BasicCommData]. This object contains the basic commissioning
    ///   data required for the device.
    /// * dev_att: An object that implements the trait [DevAttDataFetcher]. Any Matter device
    ///   requires a set of device attestation certificates and keys. It is the responsibility of
    ///   this object to return the device attestation details when queried upon.
    /// * epoch: A function of type [Epoch]. This function is responsible for providing the current
    ///   "unix" time in milliseconds
    /// * rand: A function of type [Rand]. This function is responsible for generating random data.
    /// * port: The port number on which the Matter stack will listen for incoming connections.
    pub fn init(
        dev_det: &'a BasicInfoConfig<'a>,
        dev_comm: BasicCommData,
        dev_att: &'a dyn DevAttDataFetcher,
        epoch: Epoch,
        rand: Rand,
        port: u16,
    ) -> impl Init<Self> {
        init!(
            Self {
                state <- Mutex::init(RefCell::init(MatterState::init(epoch, rand))),
                transport_mgr <- TransportMgr::init(dev_det, rand),
                persist_notification: Notification::new(),
                mdns_notification: Notification::new(),
                epoch,
                rand,
                dev_det,
                dev_comm,
                dev_att,
                port,
            }
        )
    }

    /// A utility method to replace the initial Device Attestation Data Fetcher with another one.
    pub fn replace_dev_att(&mut self, dev_att: &'a dyn DevAttDataFetcher) {
        self.dev_att = dev_att;
    }
}

impl Matter for MatterInstance<'_> {
    fn initialize_transport_buffers(&self) -> Result<(), Error> {
        self.transport_mgr.initialize_buffers()
    }

    fn dev_det(&self) -> &BasicInfoConfig<'_> {
        self.dev_det
    }

    fn dev_att(&self) -> &dyn DevAttDataFetcher {
        self.dev_att
    }

    fn dev_comm(&self) -> &BasicCommData {
        &self.dev_comm
    }

    fn port(&self) -> u16 {
        self.port
    }

    fn rand(&self) -> Rand {
        self.rand
    }

    fn epoch(&self) -> Epoch {
        self.epoch
    }

    fn state<F: FnOnce(&mut MatterState) -> R, R>(&self, f: F) -> R {
        self.state.lock(|state| f(&mut *state.borrow_mut()))
    }

    fn transport(&self) -> &TransportMgr {
        &self.transport_mgr
    }

    fn transport_rx_buffer(&self) -> impl BufferAccess<[u8]> + '_ {
        self.transport_mgr.rx_buffer()
    }

    fn transport_tx_buffer(&self) -> impl BufferAccess<[u8]> + '_ {
        self.transport_mgr.tx_buffer()
    }

    fn is_commissioned(&self) -> bool {
        self.state(|state| state.fabrics.iter().count() > 0)
    }

    async fn enable_basic_commissioning(
        &self,
        discovery_capabilities: DiscoveryCapabilities,
        timeout_secs: u16,
    ) -> Result<(), Error> {
        let buf_access = PacketBufferExternalAccess(&self.transport_mgr.rx);
        let mut buf = buf_access.get().await.ok_or(ErrorCode::NoSpace)?;

        self.state(|state| state.pase.enable_basic_pase_session(
            self.dev_comm.password,
            self.dev_comm.discriminator,
            timeout_secs,
            &mut || self.notify_mdns(),
        ))?;

        print_pairing_code_and_qr(
            self.dev_det,
            &self.dev_comm,
            discovery_capabilities,
            &mut buf,
        )?;

        Ok(())
    }

    /// Disable the basic commissioning session
    ///
    /// The method will return Ok(false) if there is no active PASE session to disable.
    fn disable_commissioning(&self) -> Result<bool, Error> {
        self.state(|state| state.pase.disable_pase_session(&mut || self.notify_mdns()))
    }

    /// Run the transport layer
    ///
    /// Enables basic commissioning if the device is not commissioned
    /// Note that the fabrics should be loaded by the PSM before calling this method
    /// or else commissioning will be always enabled.
    async fn run<S, R>(
        &self,
        send: S,
        recv: R,
        discovery_capabilities: DiscoveryCapabilities,
    ) -> Result<(), Error>
    where
        S: NetworkSend,
        R: NetworkReceive,
    {
        // TODO: Figure out why chip-tool-tests expect the device to still be in commissioning mode
        // post device reboot, even if it was already commissioned
        if !self.is_commissioned() {
            self.enable_basic_commissioning(discovery_capabilities, 0 /*TODO*/)
                .await?;
        }

        self.run_transport(send, recv).await
    }

    /// Resets the transport layer by clearing all sessions, exchanges, the RX buffer and the TX buffer
    /// NOTE: User should be careful _not_ to call this method while the transport layer and/or the built-in mDNS is running.
    fn reset_transport(&self) -> Result<(), Error> {
        self.transport_mgr.reset(self)
    }

    /// Run the transport layer
    async fn run_transport<S, R>(&self, send: S, recv: R) -> Result<(), Error>
    where
        S: NetworkSend,
        R: NetworkReceive,
    {
        self.transport_mgr.run(self, send, recv).await
    }

    /// Notify that the ACLs, Fabrics or Basic Info _might_ have changed
    /// This method is supposed to be called after processing SC and IM messages that might affect the ACLs, Fabrics or Basic Info.
    ///
    /// The default IM and SC handlers (`DataModel` and `SecureChannel`) do call this method after processing the messages.
    ///
    /// TODO: Fix the method name as it is not clear enough. Potentially revamp the whole persistence notification logic
    fn notify_persist(&self) {
        if self.fabrics_changed() || self.basic_info_changed() {
            self.persist_notification.notify();
        }
    }

    fn load_fabrics(&self, data: &[u8]) -> Result<(), Error> {
        self.state(|state| state.fabrics.load(data, &mut || self.notify_mdns()))
    }

    fn store_fabrics<'b>(&self, buf: &'b mut [u8]) -> Result<Option<&'b [u8]>, Error> {
        self.state(|state| state.fabrics.store(buf))
    }

    fn fabrics_changed(&self) -> bool {
        self.state(|state| state.fabrics.is_changed())
    }

    fn load_basic_info(&self, data: &[u8]) -> Result<(), Error> {
        self.state(|state| state.basic_info_settings.load(data))
    }

    fn store_basic_info<'b>(&self, buf: &'b mut [u8]) -> Result<Option<&'b [u8]>, Error> {
        self.state(|state| state.basic_info_settings.store(buf))
    }

    fn basic_info_changed(&self) -> bool {
        self.state(|state| state.basic_info_settings.changed)
    }

    async fn wait_persist(&self) {
        self.persist_notification.wait().await
    }

    fn mdns_services<F>(&self, mut f: F) -> Result<(), Error>
    where
        F: FnMut(MatterMdnsService) -> Result<(), Error>,
    {
        self.state(|state| {
            if let Some(service) = state.pase.mdns_service() {
                f(service)?;
            }

            for fabric in state.fabrics.iter() {
                if let Some(service) = fabric.mdns_service() {
                    f(service)?;
                }
            }

            Ok(())
        })
    }

    fn notify_mdns(&self) {
        self.mdns_notification.notify();
    }

    async fn wait_mdns(&self) {
        self.mdns_notification.wait().await
    }
}
